aal "noname" {
    language "python" {
        import pexpect
        import signal
        from mrp_resource_native import (reslib_connection)

        def start_murphy():
            global murphy
            murphy = pexpect.spawn("../src/murphyd -P ../src/.libs -c conf/murphy-lua.conf -f -vv")

        def stop_murphy():
            murphy.kill(signal.SIGKILL)

        def py_status_callback(conn, error_code, opaque):
            if conn.get_state() == "connected":
                print("We are connected!\n")

                print("Infodump:\n")

                # Let's try getting the classes
                app_classes = conn.list_application_classes()

                for app_class in app_classes:
                    print('Class: %s' % (app_class))

                # Let's try getting all the resources
                res_set = conn.list_resources()
                res_names = res_set.list_resource_names()

                for name in res_names:
                    res = res_set.get_resource_by_name(name)
                    attr_list = res.list_attribute_names()

                    print('Resource: %s' % (name))
                    for attr_name in attr_list:
                        attr = res.get_attribute_by_name(attr_name)
                        print("\tAttribute: %s = %s" % (attr_name, attr.get_value()))

            print('ResCtxCallback ErrCode: %d' % (error_code))

        class status_obj():
            def __init__(self):
                self.connection = None
                self.res_set = None

                self.conn_status_callback_called = False
                self.connected_to_murphy     = False
                self.res_set_changed         = False
                self.tests_successful        = False
    }

    # preview-show-vars: ipc_type, ipc_status, status
    # preview-depth: 20
    variables {
        ipc_list, ipc_type, ipc_status, status, connection
    }
    initial_state {
        ipc_list = []
        ipc_list.append('native')
        # ipc_list.append('dbus')
        # ipc_list.append('websocket')

        ipc_type = None
        connection = None
        ipc_status = 'uninitialized'
        status = 'shut_down'
    }

    input "init_murphy" {
        guard { return status == 'shut_down' }
        body  {
            status = 'running'
            ipc_type = ipc_list[0]
        }
        adapter {
            start_murphy()
        }
    }

    input "shut_down_murphy" {
        guard { return status == 'running' }
        body  {
            status = 'shut_down'

	    # reset all internal model variables
            ipc_type = None
            ipc_status = 'uninitialized'
        }
        adapter {
            stop_murphy()
        }
    }

    input "init_ipc" {
        guard {
            return status == 'running' and ipc_status == 'uninitialized'
	}
        body { ipc_status = 'initialized' }
        adapter {
            connection = reslib_connection(py_status_callback, status_obj())
            assert connection
        }
    }

    input "uninit_ipc" {
        guard { return status == 'running' and ipc_status == 'initialized' }
        body { ipc_status = 'uninitialized' }
        adapter {
            connection.disconnect()
            assert not connection.res_ctx and not connection.mainloop
        }
    }

    input "select_next_ipc" {
        guard { return ipc_status != 'initialized' and ipc_type and ipc_list.index(ipc_type)+1 < len(ipc_list) }
        body {
            ipc_type = ipc_list[( ipc_list.index(ipc_type) + 1 )]
        }
    }

    input "select_previous_ipc" {
        guard { return ipc_status != 'initialized' and ipc_type and ipc_list.index(ipc_type) > 0 }
        body {
            ipc_type = ipc_list[ipc_list.index(ipc_type) - 1]
        }
    }
}
